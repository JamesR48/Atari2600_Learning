
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start an unitialized segment at $80 for variable declaration
; We've memory from $80 to $FF to work with, minus a few at the
; end if we use the Stack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	seg.u Variables
        org $80

P0PosY ds 1 ; Defines 1 byte for Player0 sprite Vertical Position
P0PosX ds 1 ; Defines 1 byte for Player0 sprite Horizontal Position

P0Height equ #11

BGColor ds 1
PFColor ds 1

; words are 2 bytes long
; memory addresses are stored in 2 bytes
FighterSpritePtr word ; Pointer to P0 sprite Lookup table
FighterColorPtr word ; Pointer to P0 colors Lookup table

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Init Catridge
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	seg Code
        org $f000
        
Start:
	CLEAN_START

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initial setup of Background and Players
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda #$02
        sta COLUBK ; Set Background color
	tax
        stx BGColor

	lda #80
        sta P0PosX ; Set P0 initial Horizontal Position
	
        lda #91
        sta P0PosY ; Set P0 initial Vertical Position
        
        lda #<PlayerGraphics
        sta FighterSpritePtr ; lo-byte pointer for sprite lookuptable
        lda #>PlayerGraphics
        sta FighterSpritePtr+1 ; hi-byte pointer for sprite lookuptable
        
        lda #<PlayerColors
        sta FighterColorPtr ; lo-byte pointer for color lookuptable
        lda #>PlayerColors
        sta FighterColorPtr+1 ; hi-byte pointer for color lookuptable
        
        ldy #$35
        sty PFColor
        ; Set Control Playfield register to allow reflection        
        lda #%00000001 ; CTRLPF Register (D0 means reflect)
        sta CTRLPF
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start New Frame by configuring VBlank and VSync
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFrame:
	lda #2
        sta VSYNC ; Turn on Vertical Synchronization
        sta VBLANK ; Turn on Vertical Blank

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 3 empty Scanlines for VSYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        sta WSYNC ; Wait (Horizontal Blank) Synchronization
        sta WSYNC
        sta WSYNC
        
        lda #0
        sta VSYNC ; turn off VSYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Players Horizontal Position while in VBLank
; Using subroutine!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda P0PosX ; Load A with desired horizontal Position
        and #%01111111 ; (bitwise AND) Forces bit 7 to 0 (#$7F)
        ; So the value in (A) will always be positive (like Abs)
        
        ldy #0 ; Y assigned to Player 0
        jsr SetObjectPosX ; Jump to subroutine
        
        sta WSYNC ; Wait next Scanline
        sta HMOVE ; Apply fine position offset
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 37 empty Scanlines for VBLANK
; But this time just 35 because the Horizontal Positioning
; took 2 already
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #35
VBlankLoop:
	sta WSYNC
        dex
        bne VBlankLoop

	ldx #0
	stx VBLANK ; turn off VBLANK

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Here starts the 192 visible Scanlines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        
        ldx #192 ; X will hold the remaining Scanlines
Scanline:
	txa ; transfer X to A
        sec ; Set Carry flag before subtracting
        sbc P0PosY ; Subtract P0 sprite Y coordinate - A
        cmp P0Height ; Are we inside the sprite height bounds?
        bcc DrawPlayer0 ; If result < SpriteHeight, draw player
        lda #0 ; Else, set index to 0, turning off P0 graphics
	
DrawPlayer0:
	tay
        lda PlayerGraphics,Y ; Loop the PlayerGraphics table
        sta GRP0 ; Set the graphics of P0 for this Scanline
        lda PlayerColors,Y ; Loop the PlayerColors table
        sta COLUP0 ; Set the P0 color for this Scanline
        
        ldy PFColor
        sty COLUPF ; Set Playfield color
        ldy #%01110000
        sty PF0
        
        sta WSYNC ; Wait for Horizontal Synchronization (next Scanline)
        dex
        bne Scanline
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 30 empty Scanlines for Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #30
        lda #2
        sta VBLANK ; Turn on VBLANK
OverscanLoop:
	sta WSYNC
        dex
        bne OverscanLoop
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Testing Joystick Input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; SWCHA register stores the Joystick axis inputs in 1 byte
; 1st 4 bits are P0 Input, 2nd are P1's
; 0 means pressed, so by default they'll be #%1111 1111
; 0001 0000 - P0 Up pressed
; 0010 0000 - P0 Down pressed
; 0100 0000 - P0 Left pressed
; 1000 0000 - P0 Right pressed
CheckP0Up:
	lda #%00010000
        ; bit is like Bitwise AND, but doesn't store
        ; the result, just raise flags
        bit SWCHA
        bne CheckP0Down
	inc P0PosY
        
CheckP0Down:
	lda #%00100000
        bit SWCHA
        bne CheckP0Left
        dec P0PosY

CheckP0Left:
	lda #%01000000
        bit SWCHA
        bne CheckP0Right
        dec P0PosX

CheckP0Right:
	lda #%10000000
        bit SWCHA
        bne CheckP0Button
        inc P0PosX
        
CheckP0Button:
	lda #%10000000
        bit INPT4 ;INPT4 register stores P0's button action
        bne NoInputPressed
        inc BGColor
        lda BGColor
        sta COLUBK
        jmp NextFrame
        
NoInputPressed:
	lda #$02
        sta COLUBK ; Reset BG Color to grey
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Move P0 horizontally to the left (clamped between 50 and 75)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;lda P0PosX ; Load A with the acutal P0 Horizontal Pos
        ;cmp #50 ; Compare A with decimal #50
        ;bmi ResetP0PosX ; If A < 50 reset P0's X position
	;jmp DecrementP0PosX ; Else, keep moving left
        
;ResetP0PosX:
	;lda #75
        ;sta P0PosX
;DecrementP0PosX:
	; Decrement P0 X position each frame to make it move left
	;dec P0PosX
        
        ; Decrement P0 Y position each frame to make it move down
        ;dec P0PosY
        
        jmp NextFrame
               
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutine to set the X position of objects with fine offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;               
; (A)ccumulator register contains the desired X-coordinate
; (Y) register needs to be loaded before calling the subroutine
; Y=0 : Player 0
; Y=1 : Player 1
; Y=2 : Missile 0
; Y=3 : Missile 1
; Y=4 : Ball
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetObjectPosX subroutine
        sec ; Set Carry flag before subtracting
        sta WSYNC ; Wait next scanline      
DivisionLoop:
	sbc #15 ; Subtract 15 from A
        bcs DivisionLoop ; Loop while carry is still set (A >= 15)
        ; Meaning we can't subtract by 15 anymore (A < 15)
	; (A) will contain the division remainder minus 15 at the end
        
        ; Adjust the range of the division remainder from -8 to 7
        eor #%00000111 ; same as #7 decimal
        asl ; Shift left A by 4, HMP0 uses only the left 4bits
        asl 
        asl 
        asl 
        sta HMP0,Y ; Set fine position
        sta RESP0,Y ; Fix the player at the 15-step rough position
        
        ; Return subroutine
        ; returns Program Counter to the point where this was called
        rts 
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Array of bytes to draw the Player graphics
; These bytes are added in the final ROM addresses (from $FFE6-$FFF0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $ffe6
PlayerGraphics:
	.byte #%00000000 ; zero padding, also clears register 	
	.byte #%11100111 ; ###  ###	
        .byte #%01100110 ;  ##  ## 	
        .byte #%01100110 ;  ##  ## 	
        .byte #%11111111 ; ########	
        .byte #%11111111 ; ########	
        .byte #%11111111 ; ########	
        .byte #%10011001 ; #  ##  #	
        .byte #%10011001 ; #  ##  #	
        .byte #%11111111 ; ########	
        .byte #%01111110 ;  ######		

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Array of bytes to hold the Player colors
; These bytes are added in the final ROM addresses (from $FFF1-$FFFB)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fff1
PlayerColors:
	.byte #$00 	 ;
	.byte #$44 	 ; ###  ###
        .byte #$ac 	 ;  ##  ## 	
        .byte #$ac 	 ;  ##  ##
        .byte #$ac 	 ; ########
        .byte #$44 	 ; ########	
        .byte #$44 	 ; ########	
        .byte #$2e 	 ; #  ##  #	
        .byte #$2e 	 ; #  ##  #
        .byte #$2e 	 ; ########
        .byte #$2e 	 ;  ######

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Close Catridge
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector