
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start an unitialized segment at $80 for variable declaration
; We've memory from $80 to $FF to work with, minus a few at the
; end if we use the Stack
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	seg.u Variables
        org $80

BGColor ds 1
PFColor ds 1

P0PosY ds 1 ; Defines 1 byte for Player0 sprite Vertical Position
P0PosX ds 1 ; Defines 1 byte for Player0 sprite Horizontal Position

DemonPosY ds 1 ; Defines 1 byte for Player0 sprite Vertical Position
DemonPosX ds 1 ; Defines 1 byte for Player0 sprite Horizontal Position

; words are 2 bytes long
; memory addresses are stored in 2 bytes
PlayerSpritePtr word ; Pointer to P0 sprite Lookup table
PlayerColorPtr word ; Pointer to P0 colors Lookup table
PlayerAnimOffset byte ; P0 sprite frame offset (for animations!)

PlayerIdle0 ds 1
PlayerIdle1 ds 1

DemonSpritePtr word ; Pointer to P0 sprite Lookup table
DemonColorPtr word ; Pointer to P0 colors Lookup table

Rand8 ds 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Define Constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PO_HEIGHT equ #9
DEMON_HEIGHT equ #17

FineAdjustTable equ FineAdjustBegin - %11110001; NOTE: %11110001 = -15

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Init Catridge
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	seg Code
        org $f000
        
Start:
	CLEAN_START

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initial setup of Background and Players
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda #$02
        sta COLUBK ; Set Background color
	tax
        stx BGColor

	ldy #$35
        sty PFColor
        ; Set Control Playfield register to allow reflection        
        lda #%00000001 ; CTRLPF Register (D0 means reflect)
        sta CTRLPF

	lda #80
        sta P0PosX ; Set P0 initial Horizontal Position
        lda #18
        sta P0PosY ; Set P0 initial Vertical Position
        lda #<PlayerFront
        sta PlayerSpritePtr ; lo-byte pointer for sprite lookuptable
        lda #>PlayerFront
        sta PlayerSpritePtr+1 ; hi-byte pointer for sprite lookuptable
        lda #<PlayerColors
        sta PlayerColorPtr ; lo-byte pointer for color lookuptable
        lda #>PlayerColors
        sta PlayerColorPtr+1 ; hi-byte pointer for color lookuptable
        
        lda #20
        sta DemonPosX ; Set P0 initial Horizontal Position
        lda #68
        sta DemonPosY ; Set P0 initial Vertical Position
        lda #<DemonGraphics
        sta DemonSpritePtr ; lo-byte pointer for sprite lookuptable
        lda #>DemonGraphics
        sta DemonSpritePtr+1 ; hi-byte pointer for sprite lookuptable
        lda #<DemonColors
        sta DemonColorPtr ; lo-byte pointer for color lookuptable
        lda #>DemonColors
        sta DemonColorPtr+1 ; hi-byte pointer for color lookuptable
        lda #%00000101 ; Double size Player 1
        sta NUSIZ1
        
        lda #%1001
        sta Rand8
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start New Frame by configuring VBlank and VSync
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFrame:
	lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?

	lda #2
        sta WSYNC
        sta VSYNC ; Turn on Vertical Synchronization
        sta VBLANK ; Turn on Vertical Blank

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 3 empty Scanlines for VSYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        sta WSYNC ; Wait (Horizontal Blank) Synchronization
        sta WSYNC
        lda #0
        sta WSYNC
        sta VSYNC ; turn off VSYNC
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set Players Horizontal Position while in VBLank
; Using subroutine!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        lda P0PosX ; Load A with desired horizontal Position
        and #%01111111 ; (bitwise AND) Forces bit 7 to 0 (#$7F)
        clc
        adc #14
        ; So the value in (A) will always be positive (like Abs)
        ldy #0 ; Y assigned to Player 0
        jsr SetObjectPosX ; Jump to subroutine
        
        sta WSYNC ; Wait next Scanline
        lda DemonPosX ; Load A with desired horizontal Position
        and #%01111111 ; (bitwise AND) Forces bit 7 to 0 (#$7F)
        clc
        adc #14
        ldy #1 ; Y assigned to Player 1
        jsr SetObjectPosX ; Jump to subroutine
        
        sta WSYNC ; Wait next Scanline
        sta HMOVE ; Apply fine position offset
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 37 empty Scanlines for VBLANK
; But this time just 35 because the Horizontal Positioning
; took 2 already
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #33
VBlankLoop:
	sta WSYNC
        dex
        bne VBlankLoop

	ldx #0
	stx VBLANK ; turn off VBLANK

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Here starts the 96 visible Scanlines (because of 2-line drawing)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DrawPlayfield:
	ldy PFColor
        sty COLUPF ; Set Playfield color
        ldy #%01110000
        sty PF0 ; Draw PlayField0 pattern
        

        ldx #96 ; X will hold the remaining Scanlines
GameScanlineLoop:

.IsPlayer0InScreen:
	txa ; transfer X to A
        sec ; Set Carry flag before subtracting
        sbc P0PosY ; Subtract P0 sprite Y coordinate - A
        cmp PO_HEIGHT ; Are we inside the sprite height bounds?
        bcc .DrawPlayer0 ; If result < SpriteHeight, draw player
        lda #0 ; Else, set index to 0, turning off P0 graphics
.DrawPlayer0:
	clc ; Clear Carry flag before Adding
	adc PlayerAnimOffset ; Jump to correct sprite frame address in memory
	tay
        lda (PlayerSpritePtr),Y ; Loop the PlayerGraphics table
        sta WSYNC ; Wait for Horizontal Synchronization (next Scanline)
        sta GRP0 ; Set the graphics of P0 for this Scanline
        lda (PlayerColorPtr),Y ; Loop the PlayerColors table
        sta COLUP0 ; Set the P0 color for this Scanline
        
.IsDemonInScreen:
	txa ; transfer X to A
        sec ; Set Carry flag before subtracting
        sbc DemonPosY ; Subtract P0 sprite Y coordinate - A
        cmp DEMON_HEIGHT ; Are we inside the sprite height bounds?
        bcc .DrawDemon ; If result < SpriteHeight, draw player
        lda #0 ; Else, set index to 0, turning off P0 graphics
.DrawDemon:
	tay
        lda (DemonSpritePtr),Y ; Loop the PlayerGraphics table
        sta WSYNC ; Wait for Horizontal Synchronization (next Scanline)
        sta GRP1 ; Set the graphics of P1 for this Scanline
        lda (DemonColorPtr),Y ; Loop the PlayerColors table
        sta COLUP1 ; Set the P1 color for this Scanline
        
        dex
        bne GameScanlineLoop
        
        sta WSYNC
        ; Reset values each frame
        lda #$02
        sta COLUBK ; Reset BG Color to grey
        lda #0
        sta PlayerAnimOffset ; Reset P0 Anim frames
        lda #%00000000
        sta REFP0 ; Set P0 to not reflect
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Set 30 empty Scanlines for Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #30
        lda #2
        sta VBLANK ; Turn on VBLANK
OverscanLoop:
	sta WSYNC
        dex
        bne OverscanLoop
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Testing Joystick Input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
; SWCHA register stores the Joystick axis inputs in 1 byte
; 1st 4 bits are P0 Input, 2nd are P1's
; 0 means pressed, so by default they'll be #%1111 1111
; 0001 0000 - P0 Up pressed
; 0010 0000 - P0 Down pressed
; 0100 0000 - P0 Left pressed
; 1000 0000 - P0 Right pressed
CheckP0Up:
	lda #%00010000
        ; bit is like Bitwise AND, but doesn't store
        ; the result, just raise flags
        bit SWCHA
        bne CheckP0Down
	inc P0PosY
        
CheckP0Down:
	lda #%00100000
        bit SWCHA
        bne CheckP0Left
        dec P0PosY

CheckP0Left:
	lda #%01000000
        bit SWCHA
        bne CheckP0Right
        dec P0PosX
        lda PO_HEIGHT
        sta PlayerAnimOffset

CheckP0Right:
	lda #%10000000
        bit SWCHA
        bne CheckP0Button
        inc P0PosX
        lda PO_HEIGHT
        sta PlayerAnimOffset
        lda #%00001000
        sta REFP0
        
CheckP0Button:
	lda #%10000000
        bit INPT4 ;INPT4 register stores P0's button action
        bne NoInputPressed
        inc BGColor
        lda BGColor
        sta COLUBK
        
NoInputPressed:
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Move P0 horizontally to the left (clamped between 50 and 75)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;lda P0PosX ; Load A with the acutal P0 Horizontal Pos
        ;cmp #50 ; Compare A with decimal #50
        ;bmi ResetP0PosX ; If A < 50 reset P0's X position
	;jmp DecrementP0PosX ; Else, keep moving left
        
;ResetP0PosX:
	;lda #75
        ;sta P0PosX
;DecrementP0PosX:
	; Decrement P0 X position each frame to make it move left
	;dec P0PosX
        
        ; Decrement P0 Y position each frame to make it move down
        ;dec P0PosY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Calculations to update position for next frame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
UpdateDemonPosition:
	lda DemonPosY
        clc ; Clear carry before comparing
        cmp #0 ; compare Demon Y-Position with 0
        ; If position is < 0 (reached the bottom), reset it back to the top
        bmi ResetDemonPosition
        ;dec DemonPosY ; Else, make the Demon move down
        jmp EndPositionUpdate
ResetDemonPosition:
	lda #96 ; Because of 2-line kernel, #96 is the screen top Scanline
        sta DemonPosY
        
        jsr RandomNumGenerator
        and #97
        clc
        adc #20
        
        ;lda P0PosX
        sta DemonPosX
        
; Fall back for the Position Update code        
EndPositionUpdate:


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Jump to next frame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutine to set the X position of objects with fine offset
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;               
; (A)ccumulator register contains the desired X-coordinate
; (Y) register needs to be loaded before calling the subroutine
; Y=0 : Player 0
; Y=1 : Player 1
; Y=2 : Missile 0
; Y=3 : Missile 1
; Y=4 : Ball
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetObjectPosX subroutine
	sta WSYNC ; Wait next scanline      
        sec ; Set Carry flag before subtracting
DivisionLoop:
	sbc #15 ; Subtract 15 from A
        bcs DivisionLoop ; Loop while carry is still set (A >= 15)
        ; Meaning we can't subtract by 15 anymore (A < 15)
	; (A) will contain the division remainder minus 15 at the end
        
        ; Adjust the range of the division remainder from -8 to 7
        ;eor #%00000111 ; same as #7 decimal
        ;asl ; Shift left A by 4, HMP0 uses only the left 4bits
        ;asl 
        ;asl 
        ;asl 
        
        ; Testing the use of a look-up table for Fine Adjustment
        ; From https://www.randomterrain.com/atari-2600-memories-tutorial-andrew-davie-24.html
        tax
        lda FineAdjustTable,X
        
        sta HMP0,Y ; Set fine position
        sta RESP0,Y ; Fix the player at the 15-step rough position
        
        sta WSYNC ; Wait next Scanline
        ; Return subroutine
        ; returns Program Counter to the point where this was called
        rts 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Random number generator LFSR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; https://www.randomterrain.com/atari-2600-lets-make-a-game-spiceware-10.html
; https://www.youtube.com/watch?v=Ks1pw1X22y4
RandomNumGenerator subroutine
	lda Rand8
        lsr
        bcc NoEOR
        eor #$B4
NoEOR:
	sta Rand8
        
        rts


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Demon Graphics
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DemonGraphics:
	.byte #%00000000;
        .byte #%11000011;$34
        .byte #%11000011;$34
        .byte #%11100111;$00
        .byte #%01111110;$00
        .byte #%00111100;$34
        .byte #%11111111;$34
        .byte #%11111111;$34
        .byte #%11111111;$34
        .byte #%11111111;$34
        .byte #%11111111;$34
        .byte #%11111111;$34
        .byte #%01100110;$34
        .byte #%01111110;$34
        .byte #%11111111;$34
        .byte #%10000001;$34
        .byte #%10000001;$34

DEMON_HEIGHT = . - DemonGraphics

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Demon Color
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DemonColors:
	.byte #%00000000;
        .byte #$34;
        .byte #$34;
        .byte #$00;
        .byte #$00;
        .byte #$09;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;
        .byte #$34;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Array of bytes to draw the Player graphics
; These bytes are added in the final ROM addresses (from $FFE6-$FFF0)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;org $ffe6
PlayerFront:
	.byte #%00000000 ; zero padding, also clears register 	
	.byte #%11100111;$F6
        .byte #%01100110;$0C
        .byte #%01111110;$10
        .byte #%01111110;$F6
        .byte #%01011010;$F6
        .byte #%01111110;$0C
        .byte #%11111111;$00
        .byte #%11111111;$00		
        
; https://alienbill.com/2600/playerpalnext.html
; Dynamically calculating Sprite's height
; "." means "Current line"
PO_HEIGHT = . - PlayerFront

PlayerLeft:
	.byte #%00000000 ; zero padding, also clears register 	
	.byte #%11011100;$F6
        .byte #%01101100;$0C
        .byte #%11111100;$00
        .byte #%11111100;$F6
        .byte #%01011100;$F6
        .byte #%11111111;$0C
        .byte #%11111110;$00
        .byte #%11111110;$00

PlayerLeftWalk_01:
	.byte #%00000000 ; zero padding, also clears register
        .byte #%11000001;$F6
        .byte #%01100111;$0C
        .byte #%01111110;$00
        .byte #%01111110;$F6
        .byte #%00101110;$F6
        .byte #%01111111;$0C
        .byte #%11111111;$00
        .byte #%11111111;$00

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Array of bytes to hold the Player colors
; These bytes are added in the final ROM addresses (from $FFF1-$FFFB)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;org $fff1
PlayerColors:
	.byte #$00
	.byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$F6;
        .byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$00;
        
PlayerColors2:
	.byte #$00
	.byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$F6;
        .byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$00;

PlayerColors3:
	.byte #$00
        .byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$F6;
        .byte #$F6;
        .byte #$0C;
        .byte #$00;
        .byte #$00;
        
;---------------------------------------------------------------------------------------
; This table converts the "remainder" of the division by 15 (-1 to -15) to the correct
; fine adjustment value. This table is on a page boundary to guarantee the processor
; will cross a page boundary and waste a cycle in order to be at the precise position
; for a RESP0,x write
;---------------------------------------------------------------------------------------
FineAdjustBegin:
            DC.B %01110000; Left 7 
            DC.B %01100000; Left 6
            DC.B %01010000; Left 5
            DC.B %01000000; Left 4
            DC.B %00110000; Left 3
            DC.B %00100000; Left 2
            DC.B %00010000; Left 1
            DC.B %00000000; No movement.
            DC.B %11110000; Right 1
            DC.B %11100000; Right 2
            DC.B %11010000; Right 3
            DC.B %11000000; Right 4
            DC.B %10110000; Right 5
            DC.B %10100000; Right 6
            DC.B %10010000; Right 7
            
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Close Catridge
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
